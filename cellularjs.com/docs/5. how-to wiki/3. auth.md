# Auth
This article will show you how to create a basic `Auth` decorator helping you prevent unauthenticated user from accessing your service.

## 1. Auth decorator
*Pseudo code 1:*
```ts
import { Injectable, ProxyHandler, ProxyContext, addProxy } from '@cellularjs/di';
import {IRQ } from '@cellularjs/net';

@Injectable()
class AuthProxy implements ProxyHandler {
  constructor(
    private irq: IRQ,
    private ctx: ProxyContext,
  ) { }

  async handle() {
    const { irq, ctx } = this;

    if (!irq.header.accessToken) {
      throw new UnAuthorized();
    }

    const payload = parseJwt(irq.header.accessToken);
    if (!payload) {
      throw new UnAuthorized();
    }

    return await ctx.next();
  }
}

export const Auth = () => service => {
  addProxy(service, { proxy: AuthProxy });

  return service;
}

@Auth()
@Service({ scope: 'publish' })
export class YourProtectedService {
  // ...
}
```


*Pseudo code 2: allow client to get current logged-in user data.*

```ts {4-5,26-31,41}
import { Injectable, ProxyContext, ProxyHandler addProxy } from '@cellularjs/di';
import { IRQ } from '@cellularjs/net';

// Use a class as a token for resolving sign-in user data later.
class SignInUser {}

@Injectable()
class AuthProxy implements ProxyHandler {
  constructor(
    private irq: IRQ,
    private ctx: ProxyContext,
  ) { }

  async handle() {
    const { irq, ctx } = this;

    if (!irq.header.accessToken) {
      throw new UnAuthorized();
    }

    const payload = parseJwt(irq.header.accessToken);
    if (!payload) {
      throw new UnAuthorized();
    }

    const extModule = ctx.getExtModule();
    await extModule.addProvider({
      token: SignInUser,
      useFunc: async () => await UserModel.find(payload.userId),
      cycle: 'permanent',
    });

    return await ctx.next();
  }
}

@Auth()
@Service({ scope: 'publish' })
export class YourProtectedService {
  constructor(
    private signInUser: SignInUser,
  ) { }

  // ...
}
```